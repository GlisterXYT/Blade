_G.BLADEBALL_SCRIPT_VERSION = "V5"

-- CONFIGURATION
local WEBHOOK_URL = "https://discord.com/api/webhooks/1394346190954430496/y1TQYKAIuBUPjBHKNNiqqiMxR1rWvUCPmymOphs0LMutKalPDjuxiCHWz4isseAM9fzB"
local CHECK_INTERVAL = 300 -- 5 minutes (wins check)
local REJOIN_INTERVAL = 7200 -- 2 hour (auto rejoin)
local UPDATE_CHECK_INTERVAL = 600 -- 10 minutes (script update check)
local SCRIPT_URL = "https://raw.githubusercontent.com/GlisterXYT/Blade/refs/heads/main/Blade.txt"
local VERSION_PREFIX = '_G.BLADEBALL_SCRIPT_VERSION = "'

-- SERVICES
local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local TeleportService = game:GetService("TeleportService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local VirtualInputManager = game:GetService("VirtualInputManager")
local RunService = game:GetService("RunService")

-- PLAYER
local player = Players.LocalPlayer or Players.PlayerAdded:Wait()
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera
local placeId = game.PlaceId

-- HTTP REQUEST
local httpRequest = request or (syn and syn.request) or (http and http.request)
if not httpRequest then return warn("Executor doesn't support HTTP requests.") end

-- SCRIPT STATE
local stopScript = false
local currentVersion = nil

-- ERROR CODES
local errorCodes = {
    [404] = {keyword = "Disconnected", explanation = "You got disconnected from the server."},
    [412] = {keyword = "Failed to join", explanation = "Failed to join the server."},
    [865] = {keyword = "Server closed the connection", explanation = "Server closed the connection unexpectedly."},
    [593] = {keyword = "Timeout", explanation = "Connection timed out."},
    [724] = {keyword = "Teleport failed", explanation = "Teleportation failed."},
}

-- WEBHOOK
local function sendEmbed(title, description, color)
    local data = HttpService:JSONEncode({
        embeds = {{
            title = title,
            description = description,
            color = color,
            footer = { text = "Blade Ball Auto Tracker " .. (currentVersion or "Unknown") .. " | User: glisterx" },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
        }}
    })
    pcall(function()
        httpRequest({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = data
        })
    end)
end

-- STARTUP GUI
local function showStartupNotification()
    local gui = Instance.new("ScreenGui")
    gui.Name = "BladeBallStartupNotifyV3"
    gui.ResetOnSpawn = false
    gui.Parent = game.CoreGui

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0, 300, 0, 50)
    label.Position = UDim2.new(0.5, -150, 0.1, 0)
    label.BackgroundColor3 = Color3.new(0, 0, 0)
    label.TextColor3 = Color3.new(1, 1, 1)
    label.TextScaled = true
    label.Text = "Blade Ball Auto Tracker V3.5 Active"
    label.Parent = gui

    task.delay(10, function() gui:Destroy() end)
end

-- LOW GRAPHICS
Lighting.GlobalShadows = false
Lighting.FogEnd = 1e6
Lighting.Brightness = 0.5
Lighting.ClockTime = 14
Lighting.OutdoorAmbient = Color3.fromRGB(50, 50, 50)

for _, v in ipairs(workspace:GetDescendants()) do
    if v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Smoke") or v:IsA("Fire") or v:IsA("Sparkles") then
        v.Enabled = false
    elseif v:IsA("Decal") or v:IsA("Texture") then
        v.Transparency = 1
    elseif v:IsA("Light") then
        v.Enabled = false
    elseif v:IsA("MeshPart") or v:IsA("UnionOperation") or v:IsA("BasePart") then
        v.Material = Enum.Material.Plastic
        v.Reflectance = 0
        if v:IsA("MeshPart") then v.TextureID = "" end
    end
end

-- PRESS KEY
local function pressKey(key)
    VirtualInputManager:SendKeyEvent(true, key, false, game)
    task.wait(0.05)
    VirtualInputManager:SendKeyEvent(false, key, false, game)
end

-- SAFE TELEPORT
local function safeTeleport()
    repeat
        local success = pcall(function()
            TeleportService:Teleport(placeId, player)
        end)
        if success then break end
        task.wait(30)
    until stopScript
end

-- UPDATE CHECK
local function fetchVersion()
    local ok, res = pcall(function()
        return game:HttpGet(SCRIPT_URL)
    end)
    return ok and res:match(VERSION_PREFIX .. "([^"]+)") or nil
end

-- GET NEAREST PLAYER FUNCTION (needed for multiple tasks)
local function getNearestPlayer()
    local closest = nil
    local shortestDistance = math.huge
    local myHRP = character:FindFirstChild("HumanoidRootPart")
    if not myHRP then return nil end

    for _, p in pairs(Players:GetPlayers()) do
        if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then
            local theirHRP = p.Character.HumanoidRootPart
            local dist = (myHRP.Position - theirHRP.Position).Magnitude
            if dist < shortestDistance then
                shortestDistance = dist
                closest = theirHRP
            end
        end
    end

    return closest, shortestDistance
end

-- MAIN
local function main()
    stopScript = false
    currentVersion = fetchVersion() or "Unknown"
    showStartupNotification()
    sendEmbed("✅ Tracker Started", "Version: **" .. currentVersion .. "**", 0x00FF00)

    -- Error reconnect
    GuiService.ErrorMessageChanged:Connect(function(msg)
        if stopScript then return end
        for code, e in pairs(errorCodes) do
            if msg:find(e.keyword) then
                sendEmbed("❗ Disconnected ("..code..")", e.explanation, 0xFF0000)
                safeTeleport()
                break
            end
        end
    end)

    -- Hourly rejoin
    task.spawn(function()
        while not stopScript do
            task.wait(REJOIN_INTERVAL)
            sendEmbed("🔁 Hourly Rejoin", "Rejoining to refresh FPS...", 0x3366FF)
            safeTeleport()
        end
    end)

    -- Smart evasion movement with WASD (with direction-based hold times)
    task.spawn(function()
        local keys = {W = "W", A = "A", S = "S", D = "D"}

        local function pressMovement(direction)
            if keys[direction] then
                VirtualInputManager:SendKeyEvent(true, keys[direction], false, game)
                local holdTime = 1.5
                if direction == "W" or direction == "S" then
                    holdTime = 2.0
                elseif direction == "A" or direction == "D" then
                    holdTime = 1.0
                end
                task.wait(holdTime)
                VirtualInputManager:SendKeyEvent(false, keys[direction], false, game)
            end
        end

        while not stopScript do
            local myHRP = character:FindFirstChild("HumanoidRootPart")
            if not myHRP then task.wait(1) continue end

            local closestHRP, distance = getNearestPlayer()
            if closestHRP and distance < 30 then
                local diff = myHRP.Position - closestHRP.Position
                local moveX = math.abs(diff.X) > math.abs(diff.Z) and (diff.X > 0 and "D" or "A") or (diff.Z > 0 and "S" or "W")
                pressMovement(moveX)
                pressKey("Space")
                task.wait(0.3)
                pressKey("Space")
            end
            task.wait(1)
        end
    end)

    -- Win tracking
    local lastWins = 0
    local totalGained = 0
    local noWinIntervals = 0

    task.spawn(function()
        while not player:FindFirstChild("leaderstats") or not player.leaderstats:FindFirstChild("Wins") do task.wait(1) end
        lastWins = player.leaderstats.Wins.Value
        sendEmbed("📊 Starting Wins", "Current: **"..lastWins.."**", 0x00FF00)

        while not stopScript do
            task.wait(CHECK_INTERVAL)
            local now = player.leaderstats.Wins.Value
            local gained = now - lastWins
            lastWins = now
            if gained > 0 then
                totalGained += gained
                noWinIntervals = 0
                sendEmbed("🏆 Wins Gained", "Gained **"..gained.."**, Total: **"..totalGained.."**, Now: **"..now.."**", 0x00FF00)
            else
                noWinIntervals += 1
                sendEmbed("⏳ No Wins", "No wins this interval. Total: **"..totalGained.."**, Now: **"..now.."**", 0xFFFF00)
                if noWinIntervals >= 2 then
                    noWinIntervals = 0
                    sendEmbed("✅ Successfully Server Hopped", "No wins in 10 mins, hopping server...", 0x00FF00)
                    safeTeleport()
                end
            end
        end
    end)

    -- Check if any other player has more wins than you; if yes, hop server; else check every 5 minutes
    task.spawn(function()
        while not stopScript do
            task.wait(300) -- 5 minutes
            local leaderstats = player:FindFirstChild("leaderstats")
            if not leaderstats then continue end
            local wins = leaderstats:FindFirstChild("Wins")
            if not wins then continue end
            local myWins = wins.Value

            local someoneHasMoreWins = false
            for _, p in pairs(Players:GetPlayers()) do
                if p ~= player then
                    local pStats = p:FindFirstChild("leaderstats")
                    if pStats then
                        local pWins = pStats:FindFirstChild("Wins")
                        if pWins and pWins.Value > myWins then
                            someoneHasMoreWins = true
                            break
                        end
                    end
                end
            end

            if someoneHasMoreWins then
                sendEmbed("🔄 Server Hop Triggered", "Another player has more wins. Hopping server...", 0xFF5500)
                safeTeleport()
            end
        end
    end)

    -- Screen rotate with smooth transitions and reactive behavior
    task.spawn(function()
        local lastYaw = 0
        while not stopScript do
            task.wait(5)

            local closestHRP, distance = getNearestPlayer()
            if closestHRP then
                if distance <= 10 then
                    -- Quick random direction spin to scare off close players
                    local pos = camera.CFrame.Position
                    local randomYaw = math.rad(math.random(0, 360))
                    camera.CFrame = CFrame.new(pos, pos + Vector3.new(math.sin(randomYaw), 0, math.cos(randomYaw)))
                elseif distance <= 30 then
                    -- Smooth turn to opposite direction for 3 seconds, then back
                    local pos = camera.CFrame.Position
                    local oppositeYaw = lastYaw + math.pi
                    local startCFrame = camera.CFrame
                    local targetCFrame = CFrame.new(pos, pos + Vector3.new(math.sin(oppositeYaw), 0, math.cos(oppositeYaw)))

                    -- Smoothly rotate to opposite
                    for i = 0, 1, 0.05 do
                        camera.CFrame = startCFrame:Lerp(targetCFrame, i)
                        task.wait(0.05)
                    end

                    task.wait(3) -- hold for 3 seconds

                    -- Smoothly rotate back
                    for i = 0, 1, 0.05 do
                        camera.CFrame = targetCFrame:Lerp(startCFrame, i)
                        task.wait(0.05)
                    end
                else
                    -- Normal smooth rotation to random angle
                    local delta = math.rad(math.random(50, 180)) * (math.random(0, 1)*2-1)
                    lastYaw = lastYaw + delta
                    local pos = camera.CFrame.Position
                    local targetLookVector = Vector3.new(math.sin(lastYaw), 0, math.cos(lastYaw))
                    local startCFrame = camera.CFrame
                    local targetCFrame = CFrame.new(pos, pos + targetLookVector)

                    for i = 0, 1, 0.05 do
                        camera.CFrame = startCFrame:Lerp(targetCFrame, i)
                        task.wait(0.05)
                    end
                end
            else
                -- No player nearby, just smooth rotate randomly
                local delta = math.rad(math.random(50, 180)) * (math.random(0, 1)*2-1)
                lastYaw = lastYaw + delta
                local pos = camera.CFrame.Position
                local targetLookVector = Vector3.new(math.sin(lastYaw), 0, math.cos(lastYaw))
                local startCFrame = camera.CFrame
                local targetCFrame = CFrame.new(pos, pos + targetLookVector)

                for i = 0, 1, 0.05 do
                    camera.CFrame = startCFrame:Lerp(targetCFrame, i)
                    task.wait(0.05)
                end
            end
        end
    end)
end

-- Auto update
task.spawn(function()
    while true do
        task.wait(UPDATE_CHECK_INTERVAL)
        local newVer = fetchVersion()
        if newVer and newVer ~= currentVersion then
            sendEmbed("🔄 Script Update", "Restarting with new version **"..newVer.."**", 0x00FFFF)
            stopScript = true
            local scriptText = game:HttpGet(SCRIPT_URL)
            if scriptText then
                local f = loadstring(scriptText)
                if f then f() return end
            end
        end
    end
end)

main()
